/*
 * Copyright 1995-2018 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the OpenSSL license (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "apps.h"
#include "progs.h"
#include <openssl/err.h>
#include <openssl/objects.h>
#include <openssl/evp.h>
#include <openssl/x509.h>
#include <openssl/pkcs7.h>
#include <openssl/pem.h>

typedef enum OPTION_choice {
    OPT_ERR = -1, OPT_EOF = 0, OPT_HELP,
    OPT_INFORM, OPT_OUTFORM, OPT_IN, OPT_OUT, OPT_IN_SIGN_KEY, OPT_IN_SIGN_KEY_INDEX, OPT_IN_ENC_KEY_INDEX, OPT_NOOUT,
    OPT_TEXT, OPT_PRINT, OPT_PRINT_CERTS, OPT_ENGINE
} OPTION_CHOICE;

const OPTIONS pkcs7_options[] = {
    {"help", OPT_HELP, '-', "Display this summary"},
    {"inform", OPT_INFORM, 'F', "Input format - DER or PEM"},
    {"in", OPT_IN, '<', "Input file"},
    {"in_sign_key", OPT_IN_SIGN_KEY, '<', "Input the SM2 signature private key file generated by tasscard engine"},
    {"in_sign_key_index", OPT_IN_SIGN_KEY_INDEX, 's', "Input the SM2 signature private key index generated by tasscard engine"},
    {"in_enc_key_index", OPT_IN_ENC_KEY_INDEX, 's', "Input the SM2 encrypt private key index imported to store in tasscard engine"},
    {"outform", OPT_OUTFORM, 'F', "Output format - DER or PEM"},
    {"out", OPT_OUT, '>', "Output file"},
    {"noout", OPT_NOOUT, '-', "Don't output encoded data"},
    {"text", OPT_TEXT, '-', "Print full details of certificates"},
    {"print", OPT_PRINT, '-', "Print out all fields of the PKCS7 structure"},
    {"print_certs", OPT_PRINT_CERTS, '-',
     "Print_certs  print any certs or crl in the input"},
#ifndef OPENSSL_NO_ENGINE
    {"engine", OPT_ENGINE, 's', "Use engine, possibly a hardware device"},
#endif
    {NULL}
};

#ifndef OPENSSL_NO_CNSM
int derlen_to_bytenum(int der_len, unsigned char A[5])
{
    int	bytenum = 5;

    if( (der_len / 65536) > 255)
    {
        bytenum = 5;
        A[0] = 0x84;
        A[1] = (unsigned char)(der_len / (65536 * 256));
        A[2] = (unsigned char)( (der_len % (65536 * 256)) / 65535);
        A[3] = (unsigned char)( (der_len % 66536) / 256);
        A[4] = (unsigned char)( (der_len % 65536) % 256);
    }
    else if( (der_len / 256) > 255)
    {
        bytenum = 4;
        A[0] = 0x83;
        A[1] = (unsigned char)(der_len / 65536);
        A[2] = (unsigned char)( (der_len % 65536) / 256);
        A[3] = (unsigned char)( (der_len % 65536) % 256);
    }
    else if(der_len > 255)
    {
        bytenum = 3;
        A[0] = 0x82;
        A[1] = (unsigned char)(der_len / 256);
        A[2] = (unsigned char)(der_len % 256);
    }
    else if(der_len > 127)
    {
        bytenum = 2;
        A[0] = 0x81;
        A[1] = (unsigned char)(der_len);
    }
    else
    {
        bytenum = 1;
        A[0] = (unsigned char)(der_len);
    }
    return(bytenum);
}



int bytenum_to_derlen(unsigned char *bytes, int *lenlength, int *len)
{
    if(bytes[0] > 0x84)
        return -2;

    switch(bytes[0])
    {
    case 0x81:
        *lenlength = 2;
        *len = bytes[1];
        break;

    case 0x82:
        *lenlength = 3;
        *len = bytes[1] * 256 + bytes[2];
        break;

    default:
        *lenlength = 1;
        *len = bytes[0];
    }
    return 0;
}


int static dder_integer(unsigned char *der, unsigned char **ppinteger, int *contentlen, int *totallen)
{
    int		lencodelen, offset, integerlen, dr;

    if(der[0] != 0x02)
        return -1;
    dr = bytenum_to_derlen(der + 1, &lencodelen, &integerlen);
    if(dr != 0)
        return dr;
    offset = 1 + lencodelen;
    *totallen = 1 + lencodelen + integerlen;
    if(der[offset] == 0x00)
    {
        integerlen--;
        offset++;
    }
    *ppinteger = der + offset;
    *contentlen = integerlen;
    return 0;
}


//解字符串Der
int static dder_strstr(unsigned char *der, unsigned char **ppoctstr, int *contentlen, int *totallen)
{
        int     lencodelen, offset, octectstrlen, dr;

        if(der[0] != 0x04 && der[0] != 0x80 && der[0] != 0x06 && der[0] != 0x05 && der[0] != 0x03)
                return -1;
        dr = bytenum_to_derlen(der+1,&lencodelen,&octectstrlen);
        if(dr != 0)
                return dr;
        offset = 1+lencodelen;
        *totallen = 1+lencodelen+octectstrlen;
        *ppoctstr = der+offset;
        *contentlen = octectstrlen;
        return 0;
}

EC_KEY *calculate_sm2_key(const char *privkey_bin_string)
{
	EC_KEY *ec_key = NULL;
	EC_POINT *pubkey = NULL;
	BIGNUM *privkey = NULL;
	EC_GROUP *group = NULL;
	
	group = EC_GROUP_new_by_curve_name(NID_sm2);
	if (group == NULL)
	{
	    BIO_printf(bio_err, "Error Of Create curve of SM2\n");
		goto err;
	}
	
	if((privkey = BN_bin2bn((const unsigned char*)privkey_bin_string, 32, NULL)) == NULL){
	    BIO_printf(bio_err, "bin2bn fail!\n");
        goto err;
    }
    if ((pubkey = EC_POINT_new(group)) == NULL) goto err;
	if (!ec_key)
	{
		ec_key = EC_KEY_new();
		if (!ec_key) goto err;
		if (!EC_KEY_set_group(ec_key, group))
		{
			EC_KEY_free(ec_key);
			ec_key = NULL;
			goto err;
		}
	}

	if (!EC_POINT_mul(group, pubkey, privkey, NULL, NULL, NULL))
	{
		EC_KEY_free(ec_key);
		ec_key = NULL;
		goto err;
	}

	if (!EC_KEY_set_private_key(ec_key, privkey) || !EC_KEY_set_public_key(ec_key, pubkey))
	{
		EC_KEY_free(ec_key);
		ec_key = NULL;
		goto err;
	}

err:
    if (privkey) BN_free(privkey);
    if (pubkey) EC_POINT_free(pubkey);
    if(group) EC_GROUP_free(group);

	return ec_key;
}



//解析国密SM2双证私钥文件
int DDer_SM2Prikey_ByDoubleFile( unsigned char *DerBuf, int DerBufLen, int *iAlgflg, unsigned char **pucSymkeyCiph, int *iSymLen, unsigned char **pucSM2keyCiph, int *iEccLen )
{
        unsigned char *p = DerBuf, *tmp = NULL;
        int rv;
        unsigned char pucSm2EncOid[] = {0x2A, 0x81, 0x1C, 0xCF, 0x55, 0x01, 0x82, 0x2D, 0x03};
        unsigned char pucSm1Oid[] = {0x2A, 0x81, 0x1C, 0xCF, 0x55, 0x01, 0x66};
        
        
        int lencodelen, len, unitlen, iTmpLen;

        /****************************************************************总集合****************************************/
        if( p[0] != 0x30 )
                return 1;
        p += 1;
        //解析总编码长度并校验
        rv = bytenum_to_derlen( p, &lencodelen, &len);
        if(rv != 0)
                return rv;
        if(1 + lencodelen + len != DerBufLen )
                return 2;
        p += lencodelen;

        //版本号 - 仅解析不存储
        rv = dder_integer( p, &tmp, &iTmpLen, &unitlen );
        if( rv )
                return rv;
        p += unitlen;

        /*********************对称密钥密文集合*****************/
        //二级集合长度
        if( p[0] != 0x31 )
                return 3;
        p += 1;
        rv = bytenum_to_derlen( p, &lencodelen, &len);
        if(rv != 0)
                return rv;
        p += lencodelen;

        //三级集合长度
        if( p[0] != 0x30 )
                return 4;
        p += 1;
        rv = bytenum_to_derlen( p, &lencodelen, &len);
        if(rv != 0)
                return rv;
        p += lencodelen;

        //版本号 - 仅解析不存储
        tmp = NULL;
        rv = dder_integer( p, &tmp, &iTmpLen, &unitlen );
        if( rv )
                return rv;
        p += unitlen;

        //跳过不处理
        if( p[0] != 0x30 )
                return 5;
        p += 1;
        rv = bytenum_to_derlen( p, &lencodelen, &len);
        if(rv != 0)
                return rv;
        p += lencodelen+len;

        //SM2加密OID
        if( p[0] != 0x30 )
                return 6;
        p += 1;
        rv = bytenum_to_derlen( p, &lencodelen, &len);
        if(rv != 0)
                return rv;
        p += lencodelen;
        
        //比对sm2encrypt-oid: 1.2.156.10197.1.301.3
        tmp = NULL;
        rv = dder_strstr( p, &tmp, &iTmpLen, &unitlen );
        if( rv != 0 )
                return rv;
        
        if( memcmp( pucSm2EncOid, tmp, iTmpLen ) )
        {
                printf("SM2 Enc OID Is Failed.");
                return 7;
        }

        p += unitlen;
        /* Log_Trace1("tmp", tmp, iTmpLen); */

        //对称密钥密文 
        rv = dder_strstr( p, pucSymkeyCiph, iSymLen, &unitlen );
        if( rv != 0 )
                return rv;
        p += unitlen;
        
        /********************************** 忽略该集合 ****************************/
        if( p[0] != 0x31 )
                return 9;
        rv = bytenum_to_derlen( &p[1], &lencodelen, &len);
        if(rv != 0)
                return rv;
        p += lencodelen+len+1;
        
        /******************************** SM2私钥密文 ***************************/
        if( p[0] != 0x30 )
                return 10;
        p += 1;
        rv = bytenum_to_derlen( p, &lencodelen, &len);
        if(rv != 0)
                return rv;
        p += lencodelen;

        //oid忽略
        tmp = NULL;
        rv = dder_strstr( p, &tmp, &iTmpLen, &unitlen );
        if( rv != 0 )
                return rv;
        p += unitlen;

        if( p[0] != 0x30 )
                return 11;
        p += 1;
        rv = bytenum_to_derlen( p, &lencodelen, &len);
        if(rv != 0)
                return rv;
        p += lencodelen;

        //比对对称加密算法OID
        tmp = NULL;
        rv = dder_strstr( p, &tmp, &iTmpLen, &unitlen );
        if( rv != 0 )
                return rv;
        
        /* unsigned char pucSm4Oid[] = {0x2A, 0x81, 0x1C, 0xCF, 0x55, 0x01, 0x66} */
        if( memcmp( tmp, pucSm1Oid, iTmpLen ) == 0 )
        {
                *iAlgflg = 1;
        }
        else{
                *iAlgflg = 2;
        }

        p += unitlen;

        //sm2私钥密文
        rv = dder_strstr( p, pucSM2keyCiph, iEccLen, &unitlen );
        if( rv != 0 )
                return rv;
        p += unitlen;

        /**************************************该集合忽略***********************************/
        if( p[0] != 0xA0 )
                return 12;
        p += 1;
        rv = bytenum_to_derlen( p, &lencodelen, &len);
        if(rv != 0)
                return rv;
        p += lencodelen + len;

        /**************************************该集合忽略***********************************/
        if( p[0] != 0x31 )
                return 13;
        p += 1;
        rv = bytenum_to_derlen( p, &lencodelen, &len);
        if(rv != 0)
                return rv;
        p += lencodelen + len;

        if( (int)(p-DerBuf) != DerBufLen )
                return 14;

        return 0;
}

int b2s(char *bin, char *outs)
{
	int i = 0;
  char tmpbuf[4];
  int iRet = 0;
  char *ptr = bin;
  for(i = 0; i<strlen(bin)/2; i++){
		memset(tmpbuf, 0x00, sizeof(tmpbuf));
		memcpy(tmpbuf, ptr, 2);
		ptr += 2;
		iRet = strtol(tmpbuf, NULL, 16);
		memset(outs++, iRet, 1);
  }
  return i;
}


#endif
int pkcs7_main(int argc, char **argv)
{
    ENGINE *e = NULL;
    PKCS7 *p7 = NULL;
    BIO *in = NULL, *out = NULL;
#ifndef OPENSSL_NO_CNSM
    BIO *b64 = NULL;
    BIO *in_sign_key = NULL;
    char *infile_sign_key = NULL;
    char *in_sign_key_index = NULL;
    char *in_enc_key_index = NULL;
    int in_len = 0;
    char in_buf[4096] = {0};
    int iAlgflg = -1;
    unsigned char *pucSymkeyCiph = NULL;
    int iSymLen = 0;
    unsigned char *pucSM2keyCiph = NULL;
    unsigned char ucSM2key_enc[128] = {0};
    int iEccLen = 0;
    size_t outlen_dec = 0;
	unsigned char * out_dec = NULL;
	EVP_PKEY *pkey_dec = NULL;
	EVP_PKEY_CTX *pctx_dec = NULL;
	int outlen = 0;
	int tmplen = 0;
	EVP_CIPHER_CTX *ctx = NULL;
	unsigned char t_buf[1024] = {0};
#endif
    int informat = FORMAT_PEM, outformat = FORMAT_PEM;
    char *infile = NULL, *outfile = NULL, *prog;
    int i, print_certs = 0, text = 0, noout = 0, p7_print = 0, ret = 1;
    OPTION_CHOICE o;

    prog = opt_init(argc, argv, pkcs7_options);
    while ((o = opt_next()) != OPT_EOF) {
        switch (o) {
        case OPT_EOF:
        case OPT_ERR:
 opthelp:
            BIO_printf(bio_err, "%s: Use -help for summary.\n", prog);
            goto end;
        case OPT_HELP:
            opt_help(pkcs7_options);
            ret = 0;
            goto end;
        case OPT_INFORM:
            if(strcmp(opt_arg(), "GM009") == 0){
                informat = FORMAT_BASE64_GM009_7_4;
                break;
            }
            
            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))
                goto opthelp;
            break;
        case OPT_OUTFORM:
            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))
                goto opthelp;
            break;
        case OPT_IN:
            infile = opt_arg();
            break;
#ifndef OPENSSL_NO_CNSM            
        case OPT_IN_SIGN_KEY:
            infile_sign_key = opt_arg();
            break;
        case OPT_IN_SIGN_KEY_INDEX:
            in_sign_key_index = opt_arg();
            break;
        case OPT_IN_ENC_KEY_INDEX:
            in_enc_key_index = opt_arg();
            break;
#endif
        case OPT_OUT:
            outfile = opt_arg();
            break;
        case OPT_NOOUT:
            noout = 1;
            break;
        case OPT_TEXT:
            text = 1;
            break;
        case OPT_PRINT:
            p7_print = 1;
            break;
        case OPT_PRINT_CERTS:
            print_certs = 1;
            break;
        case OPT_ENGINE:
            e = setup_engine(opt_arg(), 0);
            break;
        }
    }
    argc = opt_num_rest();
    if (argc != 0)
        goto opthelp;

    in = bio_open_default(infile, 'r', informat);
    if (in == NULL)
        goto end;
#ifndef OPENSSL_NO_CNSM
    if(infile_sign_key != NULL || in_sign_key_index != NULL){
        
        //check infile_sign_key and in_sign_key_index args, must be have only one
        if(infile_sign_key != NULL && in_sign_key_index != NULL){
            BIO_printf(bio_err, "Optione in_sign_key and in_sign_key_index can only choose one!\n");
            goto end;
        }
        
        if(in_sign_key_index != NULL && e == NULL){
            BIO_printf(bio_err, "If in_sign_key_index set, you must set the engine by '-engine val' option!\n");
            goto end;
        }
        
        b64 = BIO_new(BIO_f_base64());
        if (b64 == NULL)
            goto end;
        BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);
        b64 = BIO_push(b64, in);
        
        in_len = BIO_read(b64,  in_buf, sizeof(in_buf));
        
        if(informat == FORMAT_BASE64_GM009_7_4){
            //in_len -= 15;      //jump the header of sequence:30820xxx 3009 06072A811CCF550168  oid:1-2-156-10197-1-104(SM4)
            if(atoi(in_sign_key_index)>=0 && atoi(in_sign_key_index) <=64){
                //printf("do nothing, use the card ENGINE_convert_private_key do all the parse!\n");
            }else{
                memcpy(t_buf, in_buf+15, 2);        //3079
                iSymLen = *(unsigned char *)(t_buf+1);      //the t_buf[1] bytes len, like 0x79.
                memcpy(t_buf+2, in_buf+15+2, iSymLen);
                
                iSymLen += 2;       //add the head of 0x3079
                pucSymkeyCiph = t_buf;
                
                iEccLen = 64;
                pucSM2keyCiph = (unsigned char *)in_buf + in_len - 64;        //get the last 64 bytes as the ciphered enc private key
            }
            
        }else{
            in_len -= 20;        //jump the header of sequence: 3082049D  060A2A811CCF550601040204  A082048D
            
            if( 0 != DDer_SM2Prikey_ByDoubleFile((unsigned char *)in_buf + 20, in_len, &iAlgflg, &pucSymkeyCiph, &iSymLen, &pucSM2keyCiph, &iEccLen )){
                BIO_printf(bio_err, "DDer_SM2Prikey_ByDoubleFile fail!\n");
                goto end;
            }
        }
        if(in_sign_key_index && atoi(in_sign_key_index)>=0 && atoi(in_sign_key_index) <=64){
            
        }else{
            /* 11111-Parse the ciphered sm4 key by the sm2 sign private key */
            if(infile_sign_key != NULL){
                in_sign_key = bio_open_default(infile_sign_key, 'r', informat);
                if (in_sign_key == NULL)
                    goto end;
                pkey_dec = PEM_read_bio_PrivateKey(in_sign_key, NULL, NULL, NULL);
            }else if(in_sign_key_index != NULL){
                pkey_dec = ENGINE_load_private_key(e, in_sign_key_index, NULL, NULL);
            }
            
            pctx_dec = EVP_PKEY_CTX_new_pkey_id(pkey_dec, NID_sm2, NULL);
            if (!pctx_dec)
            {
            	BIO_printf(bio_err, "Create EVP_PKEY_CTX dec Error.\n");
            	goto end;
            }
            
            if (EVP_PKEY_decrypt_init(pctx_dec) != 1)
            {
            	BIO_printf(bio_err, "Error Of EVP_PKEY_decrypt_init dec.\n");
            	goto end;
            }
            
            /*Calculate Cipher Text Length*/
            if (EVP_PKEY_decrypt(pctx_dec, NULL, &outlen_dec, pucSymkeyCiph, iSymLen) != 1)
            {
            	BIO_printf(bio_err, "Error Of len EVP_PKEY_decrypt use the sign key to dec the symkeycipher.\n");
            	goto end;
            }
            
            out_dec = OPENSSL_malloc(outlen_dec+1);
            if (!out_dec)
            {
            	BIO_printf(bio_err, "Error Of Alloc dec  memory.\n");
            	goto end;
            }
	        
            if (EVP_PKEY_decrypt(pctx_dec, out_dec, &outlen_dec, pucSymkeyCiph, iSymLen) != 1)
            {
            	BIO_printf(bio_err, "Error Of EVP_PKEY_decrypt use the sign key to dec the symkeycipher.\n");
            	goto end;
            }
	        out_dec[outlen_dec] = '\0';
	        
	        
	        /* 22222-Use the plain sm4 key to dec the sm2 enc key */
            //unsigned char key[] = "0123456789";
	        if((ctx = EVP_CIPHER_CTX_new()) == NULL){
	            BIO_printf(bio_err, "ctx new fail!\n");
	            goto end;
            }
            
            
            EVP_CIPHER_CTX_init(ctx);
            EVP_CipherInit_ex(ctx, EVP_sm4_ecb(), NULL, out_dec, NULL, 0);
            
            EVP_CIPHER_CTX_set_padding(ctx, 0);
            
            if(!EVP_CipherUpdate(ctx, ucSM2key_enc, &outlen, pucSM2keyCiph, iEccLen))
            {
                BIO_printf(bio_err, "EVP_CipherUpdate fail!\n");
                goto end;
            }
            
            if(!EVP_DecryptFinal_ex(ctx, ucSM2key_enc + outlen, &tmplen))
            {
               BIO_printf(bio_err, "EVP_EncryptFinal_ex fail!\n");
               goto end;
            }
            outlen += tmplen;
            
            
            EVP_CIPHER_CTX_cleanup(ctx);
        }
        
        
        /* 33333-write the enc key to outfile*/
        if(e){
            if(in_enc_key_index && atoi(in_enc_key_index)>=0 && atoi(in_enc_key_index) <=64){       //input the enc key index, import the enc key to tasscard 
                //use the in_buf[in_len] store the in_sign_key_index
                in_buf[in_len] = atoi(in_sign_key_index);
                ENGINE_convert_private_key(e, (const char *)in_buf, in_len, NULL, in_enc_key_index);
            }else{
                ENGINE_convert_private_key(e, (const char *)ucSM2key_enc+32, 32, (unsigned char *)outfile, NULL);
            }
        }
            
        else{
            EC_KEY *ec_key = NULL;
            BIO *mem_b = NULL;
            ec_key = calculate_sm2_key((const char *)ucSM2key_enc+32);
            if(ec_key == NULL){
                BIO_printf(bio_err,"calculate_sm2_key fail, may be you forget specifies the -engine when using a signed key generated by tasscard engine!\n", outfile);
                goto end;
            }
            
            if(outfile != NULL){
                mem_b=BIO_new_file(outfile,"w");
	            if(mem_b == NULL){
	        	    BIO_printf(bio_err,"open key_outfile %s fail!\n", outfile);
	        	    goto end;
	            }
	        }else{
	            mem_b= BIO_new_fp(stdout, BIO_NOCLOSE);
                if(mem_b == NULL){
                	BIO_printf(bio_err,"open stderr fail!\n");
                	goto end;
                }
            }
	            
	        ret= PEM_write_bio_ECPrivateKey(mem_b, ec_key, NULL, NULL, 0, NULL, NULL);
	        if(ret!=1)
	        {
	        	goto end;
	        }
	        if(mem_b) BIO_free(mem_b);
            if(ec_key) EC_KEY_free(ec_key);
        }
        
        ret = 0;
        goto end;
            
            
    }
#endif    
    
    if (informat == FORMAT_ASN1)
        p7 = d2i_PKCS7_bio(in, NULL);
    else
        p7 = PEM_read_bio_PKCS7(in, NULL, NULL, NULL);
    if (p7 == NULL) {
        BIO_printf(bio_err, "unable to load PKCS7 object\n");
        ERR_print_errors(bio_err);
        goto end;
    }

    out = bio_open_default(outfile, 'w', outformat);
    if (out == NULL)
        goto end;

    if (p7_print)
        PKCS7_print_ctx(out, p7, 0, NULL);

    if (print_certs) {
        STACK_OF(X509) *certs = NULL;
        STACK_OF(X509_CRL) *crls = NULL;

        i = OBJ_obj2nid(p7->type);
        switch (i) {
        case NID_pkcs7_signed:
        case NID_pkcs7_sm2_signed:
            if (p7->d.sign != NULL) {
                certs = p7->d.sign->cert;
                crls = p7->d.sign->crl;
            }
            break;
        case NID_pkcs7_signedAndEnveloped:
        case NID_pkcs7_sm2_signedAndEnveloped:
            if (p7->d.signed_and_enveloped != NULL) {
                certs = p7->d.signed_and_enveloped->cert;
                crls = p7->d.signed_and_enveloped->crl;
            }
            break;
        default:
            break;
        }

        if (certs != NULL) {
            X509 *x;

            for (i = 0; i < sk_X509_num(certs); i++) {
                x = sk_X509_value(certs, i);
                if (text)
                    X509_print(out, x);
                else
                    dump_cert_text(out, x);

                if (!noout)
                    PEM_write_bio_X509(out, x);
                BIO_puts(out, "\n");
            }
        }
        if (crls != NULL) {
            X509_CRL *crl;

            for (i = 0; i < sk_X509_CRL_num(crls); i++) {
                crl = sk_X509_CRL_value(crls, i);

                X509_CRL_print_ex(out, crl, get_nameopt());

                if (!noout)
                    PEM_write_bio_X509_CRL(out, crl);
                BIO_puts(out, "\n");
            }
        }

        ret = 0;
        goto end;
    }

    if (!noout) {
        if (outformat == FORMAT_ASN1)
            i = i2d_PKCS7_bio(out, p7);
        else
            i = PEM_write_bio_PKCS7(out, p7);

        if (!i) {
            BIO_printf(bio_err, "unable to write pkcs7 object\n");
            ERR_print_errors(bio_err);
            goto end;
        }
    }
    ret = 0;

end:
    PKCS7_free(p7);
    release_engine(e);
#ifndef OPENSSL_NO_CNSM
    if(b64)
        BIO_free(b64);
    BIO_free(in_sign_key);
    if(pctx_dec)
        EVP_PKEY_CTX_free(pctx_dec);
    if(ctx)
        EVP_CIPHER_CTX_free(ctx);
    if(out_dec)
        OPENSSL_free(out_dec);
    if(pkey_dec)
        EVP_PKEY_free(pkey_dec);
#endif
    BIO_free(in);
    BIO_free_all(out);

    return ret;
}
